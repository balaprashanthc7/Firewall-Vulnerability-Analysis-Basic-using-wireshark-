import os
import pyshark
import scapy.all as scapy
from scapy.layers.inet import IP, TCP
from datetime import datetime
import xml.etree.ElementTree as ET
import tkinter as tk
from tkinter import scrolledtext, messagebox
from tkinter import filedialog

# Define the ports to scan
ports = [21, 22, 23, 25, 53, 80, 443]

# Function definitions for scanning and analysis
def reconnaissance(target_ip):
    print(f"[{datetime.now()}] Starting reconnaissance on {target_ip}")
    os.system(f"nslookup {target_ip}")
    os.system(f"whois {target_ip}")

def scan(target_ip, ports):
    print(f"[{datetime.now()}] Starting scanning on {target_ip}")
    open_ports = []
    for port in ports:
        pkt = scapy.sr1(IP(dst=target_ip)/TCP(dport=port, flags="S"), timeout=1, verbose=0)
        if pkt and pkt.haslayer(TCP) and pkt[TCP].flags == 0x12:
            open_ports.append(port)
            scapy.sr(IP(dst=target_ip)/TCP(dport=port, flags="R"), timeout=1, verbose=0)
    return open_ports

def run_nmap(target_ip):
    print(f"[{datetime.now()}] Running Nmap scan on {target_ip}")
    command = f"nmap -sV --script vulners -oX nmap_scan.xml {target_ip}"
    os.system(command)

    vulnerabilities = []
    tree = ET.parse('nmap_scan.xml')
    root = tree.getroot()
    for host in root.iter('host'):
        for port in host.iter('port'):
            for script in port.iter('script'):
                if script.attrib.get('id') == 'vulners':
                    for elem in script.iter('elem'):
                        vulnerabilities.append(elem.text)

    return vulnerabilities

def dynamic_analysis(target_ip):
    print(f"[{datetime.now()}] Starting dynamic analysis on {target_ip}")
    capture = pyshark.LiveCapture(interface='eth0', bpf_filter=f"host {target_ip}")
    capture.sniff(timeout=10)
    return capture

def gain_access(target_ip, open_ports):
    print(f"[{datetime.now()}] Trying to gain access to {target_ip}")
    access_gained = False
    for port in open_ports:
        if port in [80, 443]:
            access_gained = True
            break
    return access_gained

def maintain_access():
    print(f"[{datetime.now()}] Trying to maintain access")
    persistent_access = True
    return persistent_access

def audit_firewall_rules(target_ip):
    # Placeholder function for auditing firewall rules
    print(f"[{datetime.now()}] Auditing firewall rules for {target_ip}")

    # Rule categories
    categories = [
        "Allow/Deny Traffic Based on Source/Destination IP Address",
        "Port-Based Rules",
        "Protocol-Based Rules",
        "Stateful Inspection",
        "Application Layer Filtering",
        "Time-Based Rules",
        "Logging Rules",
        "VPN Traffic Rules",
        "Intrusion Prevention/Detection Rules",
        "Default Rules"
    ]

    # Example checks (replace with actual rule checks)
    for category in categories:
        print(f"Checking {category}...")
        # Example checks - replace with actual logic based on your firewall rules
        if category == "Allow/Deny Traffic Based on Source/Destination IP Address":
            # Example: Check if specific IP addresses are allowed/denied
            pass
        elif category == "Port-Based Rules":
            # Example: Check if specific ports are allowed/denied
            pass
        elif category == "Protocol-Based Rules":
            # Example: Check if specific protocols (TCP, UDP, ICMP) are allowed/denied
            pass
        elif category == "Stateful Inspection":
            # Example: Check if stateful inspection rules are correctly configured
            pass
        elif category == "Application Layer Filtering":
            # Example: Check if application layer filtering rules are correctly configured
            pass
        elif category == "Time-Based Rules":
            # Example: Check if time-based access rules are correctly configured
            pass
        elif category == "Logging Rules":
            # Example: Check if logging rules are enabled for specific traffic
            pass
        elif category == "VPN Traffic Rules":
            # Example: Check if VPN traffic rules allow/deny specific connections
            pass
        elif category == "Intrusion Prevention/Detection Rules":
            # Example: Check if IPS/IDS rules are correctly detecting/preventing intrusions
            pass
        elif category == "Default Rules":
            # Example: Check default action (allow all, deny all) when no specific rules match
            pass

    messagebox.showinfo("Firewall Rules Audit", f"Auditing firewall rules for {target_ip} completed.")

def generate_report_text(target_ip, open_ports, access_gained, persistent_access, vulnerabilities_exploited, firewall_detected):
    if not vulnerabilities_exploited:
        vulnerabilities_exploited = ["No Vulnerabilities Detected!"]

    firewall_detection = "Firewall Detected" if firewall_detected else "No Firewall Detected"

    report = f"""
Firewall Vulnerability Analysis
===============================
Target IP: {target_ip}

1. Reconnaissance
-----------------
- Whois and nslookup performed

2. Scanning
-----------
- Open Ports: {open_ports}
- Vulnerabilities Exploited: {", ".join(vulnerabilities_exploited)}

3. Gaining Access
-----------------
- Access Gained: {access_gained}

4. Maintaining Access
---------------------
- Persistent Access: {persistent_access}

5. Analysis
-----------
- Sensitive Data Accessed: Simulated
- Time Undetected: Simulated

Firewall Status
---------------
- {firewall_detection}
"""
    return report

def check_firewall(ip):
    # Check if a firewall is present using a TCP SYN scan on port 80 (HTTP)
    try:
        pkt = scapy.sr1(IP(dst=ip)/TCP(dport=80, flags="S"), timeout=1, verbose=0)
        if pkt and pkt.haslayer(TCP) and pkt[TCP].flags == 0x12:
            return False  # Port 80 is open, firewall may not be present
        else:
            return True   # Port 80 is closed or filtered, firewall likely present
    except Exception as e:
        print(f"Exception occurred during firewall check: {str(e)}")
        return True   # Assume firewall presence if an exception occurs

def start_analysis():
    target_ip = ip_entry.get()
    if target_ip:
        reconnaissance(target_ip)
        
        # Check firewall presence
        firewall_detected = check_firewall(target_ip)
        
        if not firewall_detected:
            open_ports = scan(target_ip, ports)
            vulnerabilities_exploited = run_nmap(target_ip)
            capture = dynamic_analysis(target_ip)
            access_gained = gain_access(target_ip, open_ports)
            persistent_access = maintain_access()

            # Audit firewall rules
            audit_firewall_rules(target_ip)

            # For demonstration, generate a report text
            report_text = generate_report_text(target_ip, open_ports, access_gained, persistent_access, vulnerabilities_exploited, firewall_detected)
            output_text.config(state=tk.NORMAL)
            output_text.delete('1.0', tk.END)
            output_text.insert(tk.END, report_text)
            output_text.config(state=tk.DISABLED)

            download_button.config(state=tk.NORMAL)
        else:
            messagebox.showwarning("Firewall Detected", f"A firewall is likely present on {target_ip}. Unable to proceed with analysis.")
    else:
        messagebox.showwarning("Warning", "Please enter a valid IP address.")

def download_report():
    report_text = output_text.get('1.0', tk.END)
    file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt")])
    if file_path:
        with open(file_path, "w") as file:
            file.write(report_text)
        messagebox.showinfo("Download", "Report downloaded successfully.")



# Main tkinter window
window = tk.Tk()
window.title("Firewall Vulnerability Analysis")
window.geometry("800x600")  # Expanded size for the window
window.configure(bg='black')  # Set background color to black

# Custom style for buttons and text
button_style = {'foreground': '#00ff29', 'background': 'black', 'font': ('Arial', 12)}
label_style = {'foreground': '#00ff29', 'background': 'black', 'font': ('Arial', 12)}
text_style = {'foreground': '#00ff29', 'background': 'black', 'font': ('Arial', 12)}

# Input and button widgets
ip_label = tk.Label(window, text="Enter the target IP address:", **label_style)
ip_label.pack(pady=10)

ip_entry = tk.Entry(window, width=20, font=('Arial', 12))
ip_entry.pack()

button_frame = tk.Frame(window, bg='black')
button_frame.pack(pady=10)

analyze_button = tk.Button(button_frame, text="Start Analysis", command=start_analysis, **button_style)
analyze_button.pack(side=tk.LEFT, padx=10)

# Download button
download_button = tk.Button(button_frame, text="Download Report", command=download_report, state=tk.DISABLED, **button_style)
download_button.pack(side=tk.LEFT, padx=10)

# Output text area
output_text = scrolledtext.ScrolledText(window, width=200, height=150, wrap=tk.WORD, font=('Arial', 12), bg='black', fg='#00ff29')
output_text.pack(pady=10)
output_text.config(state=tk.DISABLED)

window.mainloop()
